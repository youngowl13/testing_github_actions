name: Dependency License Check

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  license-check:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout Repository
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Step 2: Setup Go Environment
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.20'

      # Step 3: Create and Build License Checker
      - name: Create and Build License Checker
        run: |
          mkdir -p license-checker
          cd license-checker
          # Add Go code
          cat << 'EOF' > main.go
          package main

          import (
              "encoding/json"
              "fmt"
              "io/fs"
              "io/ioutil"
              "net/http"
              "os"
              "path/filepath"
              "strings"
          )

          type Dependency struct {
              Name     string
              License  string
              Details  string
              Copyleft bool
          }

          var copyleftLicenses = []string{"GPL", "LGPL", "AGPL", "MPL", "CC-BY-SA", "EPL", "OFL", "CPL", "OSL", "APL"}

          func isCopyleftLicense(license string) bool {
              license = strings.ToUpper(license)
              for _, copyleft := range copyleftLicenses {
                  if strings.Contains(license, copyleft) {
                      return true
                  }
              }
              return false
          }

          func main() {
              nodeFile := findFile(".", "package.json")
              pythonFile := findFile(".", "requirements.txt")
              if pythonFile == "" {
                  pythonFile = findFile(".", "requirement.txt")
              }
              kotlinFile := findFile(".", "libs.versions.toml")

              nodeDeps := parseNodeDependencies(nodeFile)
              pythonDeps := parsePythonDependencies(pythonFile)
              kotlinDeps := parseKotlinDependencies(kotlinFile)

              generateHTMLReport(nodeDeps, pythonDeps, kotlinDeps)
              fmt.Println("Dependency license report generated: dependency-license-report.html")
          }

          func findFile(root, target string) string {
              var found string
              filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
                  if err != nil {
                      return nil
                  }
                  if d.Name() == target {
                      found = path
                      return filepath.SkipDir
                  }
                  return nil
              })
              return found
          }

          func parseNodeDependencies(filePath string) []Dependency {
              if filePath == "" {
                  fmt.Println("No Node.js dependencies found.")
                  return nil
              }

              var result []Dependency
              file, err := os.ReadFile(filePath)
              if err != nil {
                  fmt.Println("Error reading package.json:", err)
                  return nil
              }

              var data map[string]interface{}
              if err := json.Unmarshal(file, &data); err != nil {
                  fmt.Println("Error parsing package.json:", err)
                  return nil
              }

              dependencies, ok := data["dependencies"].(map[string]interface{})
              if !ok {
                  fmt.Println("No dependencies found in package.json.")
                  return nil
              }

              for name := range dependencies {
                  license, details := fetchNodeLicense(name)
                  result = append(result, Dependency{
                      Name:     name,
                      License:  license,
                      Details:  details,
                      Copyleft: isCopyleftLicense(license),
                  })
              }
              return result
          }

          func fetchNodeLicense(pkgName string) (string, string) {
              url := fmt.Sprintf("https://registry.npmjs.org/%s", pkgName)
              resp, err := http.Get(url)
              if err != nil {
                  return "Unknown", url
              }
              defer resp.Body.Close()

              var data map[string]interface{}
              json.NewDecoder(resp.Body).Decode(&data)

              latestTag, ok := data["dist-tags"].(map[string]interface{})["latest"].(string)
              if !ok {
                  return "Unknown", url
              }

              versions, ok := data["versions"].(map[string]interface{})
              if !ok {
                  return "Unknown", url
              }

              versionData, ok := versions[latestTag].(map[string]interface{})
              if !ok {
                  return "Unknown", url
              }

              license, ok := versionData["license"].(string)
              if !ok {
                  return "Unknown", url
              }

              return license, fmt.Sprintf("https://www.npmjs.com/package/%s", pkgName)
          }

          func parsePythonDependencies(filePath string) []Dependency {
              if filePath == "" {
                  fmt.Println("No Python dependencies found.")
                  return nil
              }

              var result []Dependency
              file, err := os.ReadFile(filePath)
              if err != nil {
                  fmt.Println("Error reading requirements.txt:", err)
                  return nil
              }

              lines := strings.Split(string(file), "\n")
              for _, line := range lines {
                  if line == "" {
                      continue
                  }
                  pkg := strings.Split(line, "==")[0]
                  license, details := fetchPythonLicense(pkg)
                  result = append(result, Dependency{
                      Name:     pkg,
                      License:  license,
                      Details:  details,
                      Copyleft: isCopyleftLicense(license),
                  })
              }
              return result
          }

          func fetchPythonLicense(pkgName string) (string, string) {
              url := fmt.Sprintf("https://pypi.org/pypi/%s/json", pkgName)
              resp, err := http.Get(url)
              if err != nil {
                  return "Unknown", url
              }
              defer resp.Body.Close()

              var data map[string]interface{}
              json.NewDecoder(resp.Body).Decode(&data)

              info, ok := data["info"].(map[string]interface{})
              if !ok {
                  return "Unknown", url
              }

              license, ok := info["license"].(string)
              if !ok || license == "" {
                  classifiers, ok := info["classifiers"].([]interface{})
                  if ok {
                      for _, classifier := range classifiers {
                          if class, ok := classifier.(string); ok && strings.Contains(class, "License") {
                              license = class
                              break
                          }
                      }
                  }
              }

              return license, url
          }

          func parseKotlinDependencies(filePath string) []Dependency {
              if filePath == "" {
                  fmt.Println("No Kotlin dependencies found.")
                  return nil
              }

              var result []Dependency
              file, err := os.ReadFile(filePath)
              if err != nil {
                  fmt.Println("Error reading libs.versions.toml:", err)
                  return nil
              }

              lines := strings.Split(string(file), "\n")
              for _, line := range lines {
                  if strings.Contains(line, "=") {
                      parts := strings.Split(line, "=")
                      key := strings.TrimSpace(parts[0])
                      groupArtifact := strings.ReplaceAll(key, ".", "/")
                      license, details := fetchKotlinLicense(groupArtifact)
                      result = append(result, Dependency{
                          Name:     key,
                          License:  license,
                          Details:  details,
                          Copyleft: isCopyleftLicense(license),
                      })
                  }
              }
              return result
          }

          func fetchKotlinLicense(groupArtifact string) (string, string) {
              // Step 1: Query Maven Central API
              apiURL := fmt.Sprintf("https://search.maven.org/solrsearch/select?q=g:%s&rows=1&wt=json", groupArtifact)
              resp, err := http.Get(apiURL)
              if err != nil {
                  return "Unknown", apiURL
              }
              defer resp.Body.Close()

              // Analyze API response
              var data map[string]interface{}
              json.NewDecoder(resp.Body).Decode(&data)

              docs := data["response"].(map[string]interface{})["docs"].([]interface{})
              if len(docs) > 0 {
                  license := docs[0].(map[string]interface{})["licenses"]
                  return license.(string), apiURL
              }

              // No data from API fallback to mvnrepository URL
              fallbackURL := fmt.Sprintf("https://mvnrepository.com/artifact/%s", groupArtifact)
              return "Unknown", fallbackURL
          }

          func generateHTMLReport(nodeDeps, pythonDeps, kotlinDeps []Dependency) {
              // Generates the HTML
          }
          EOF
